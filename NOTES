Written by Neil Booth, 2005-2007.

A software arbitrary-precision floating-point implementation.  Written
for clarity rather than speed, in particular targetting use in the
front-end of a multi-target compiler so that target arithmetic can be
performed on the host.  Perhaps useful as a reference implementation
for a run-time library during development of a faster target-specific
one.

All 5 rounding modes in the IEEE-754R draft are handled correctly for
all implemented operations.  Currently implemented operations are add,
subtract, multiply, divide, fused-multiply-add, conversion-to-integer
and conversion-from-integer.  It also reads correctly-formed
hexadecimal floating point numbers as per C99; syntax is not checked.
Conversion from decimal is not currently supported.

Four formats are built-in: IEEE single precision, double precision,
quadruple precision, and x87 80-bit extended double (when operating
with full extended precision).  Adding a new format that obeys IEEE
semantics requires just one line of code to describe the format.

All operations return exceptions raised as a bit-mask, so multiple
operations can be done consecutively and their results or-ed together
if desired.  This can be useful for compiler diagnostics - inexact,
underflow and overflow can be easily diagnosed on constant folding,
and compiler optimizers can determine what exceptions would be raised
by various operations and optimize accordingly.

At present, underflow tininess is detected after rounding; it should
be straight forward to add support for the before-rounding case too.

Non-zero finite numbers are represented internally as a sign bit, a
16-bit signed exponent, and the significand as an array of integer
parts.  After normalization of a number of precision P the exponent is
within the range of the format, and if the number is not denormal the
P-th bit of the significand is set as an explicit integer bit.  For
denormals the most significant bit is shifted right so that the
exponent is maintained at the format's minimum, so that the smallest
denormal has just the least significant bit of the significand set.
The sign of zeroes and infinities is significant; the exponent and
significand of such numbers is indeterminate and meaningless.
Similarly, but also including the sign bit, for QNaNs.

TODO
----

Some features that may or may not be worth adding:

Conversions to and from decimal strings (hard).
Conversions to hexadecimal string.
Read and write IEEE-format memory representations.
Optional ability to detect underflow tininess before rounding.
New formats: x87 in single and double precision mode (extended
exponent range) and IBM two-double extended precision (hard).
New operations: sqrt, copysign, nextafter, nexttoward.